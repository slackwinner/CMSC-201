# File: hw6_part6.py
# Author: Dane Magbuhos
# Date: 11/16/17
# Section: 20
# E-mail: mag4@umbc.edu
# Description: This program generates a certain amount of rows
#              recursively to create Pascal's Triangle.

# Represents the lowest boundary and starting number
LOWER_BOUND = 0

# Used to increase or decrease a number by given value
INCREMENT = 1
DECREMENT = 1

# Used to denote the default value of Pascal's Triangle
DEFAULT_VALUE = 1

##############################################################################
# printPascalTriangle() outputs the 2D list of levelList
# Input:                levelList, 2D list of ints, rows of Pascal's Triangle
# Output:               None; Serves as a print function

def printPascalTriangle(levelList):
    
    # Traverses through 2D list and outputs each row
    row = LOWER_BOUND
    while row < len(levelList):
        col = LOWER_BOUND

        while col < len(levelList[row]):
            print(levelList[row][col], end="  ")
            col += INCREMENT

        print()
        row += INCREMENT

##################################################################################
# computeFactorial() computes the product of the non-cancelled out factorial
# Input:             evaluatedNum; an int; represents starting point of factorial
#                    boundary; an int; represents stopping point of factorial
# Output:            product; am int; represents the final answer from factorial

def computeFactorial(evaluatedNum, boundary):

    product = evaluatedNum
    currentNum = evaluatedNum - DECREMENT

    while currentNum > boundary:
        product *= currentNum
        currentNum -= DECREMENT
    
    return product

#######################################################################################
# computeNChooseK() designates the cancelled out and remaining factorials
# Input:            numerator; an int; conveys numerator's factorial
#                   currentDenominator; an int; conveys currentDenominator's factorial
# Output:           combinations; an int; one of pascal's integers

def computeNChooseK(numerator, currentDenominator):

    greatestDenominatorFactor = LOWER_BOUND
    leastDenominatorFactor = LOWER_BOUND
    
    # Handles outer 1's case
    if currentDenominator == LOWER_BOUND or numerator - currentDenominator == LOWER_BOUND:
        return DEFAULT_VALUE
    
    # Handles the case where cancelled out factorial is greater than the currentDenominator
    elif numerator - currentDenominator > currentDenominator:
        greatestDenominatorFactor = numerator - currentDenominator
        leastDenominatorFactor = currentDenominator

    else:
        # Sets the cancelled factorial and the remaining factorial
        leastDenominatorFactor = numerator - currentDenominator 
        greatestDenominatorFactor = currentDenominator 

    # Calls factorial function and compute the product of the non-cancelled out factorials 
    num = computeFactorial(numerator, greatestDenominatorFactor)
    denom = computeFactorial(leastDenominatorFactor, DEFAULT_VALUE)

    # Calculates the pascal integer
    combinations = num // denom

    return combinations

################################################################################
# getPascalIntegers() gathers all binomial coefficients at each pascal row
# Input:              currLevel; an int; current pascal row
# Output:             currentRowList; a list; all pascals integers for each row

def getPascalIntegers(currLevel):
    
    currentDenominator = LOWER_BOUND
    currentRowList = []

    while currentDenominator <= currLevel:
        combinations = computeNChooseK(currLevel, currentDenominator)
        currentRowList.append(combinations)
        currentDenominator += INCREMENT
    
    return currentRowList

######################################################################################
# pascal() uses recursion to create each level of Pascal's triangle, reaching
#          the requested height
# Input:   currLevel; an int; the current level being created
#          levelsToMake; an int; the number of levels requested
#          levelList; a 2D list of ints
# Output:  None(levelList is changed in place, and the updated levelList will be 
#          same in main())

def pascal(currLevel, levelsToMake, levelList):

    if currLevel > levelsToMake:
        printPascalTriangle(levelList)

    else:
        pascalList = getPascalIntegers(currLevel)
        levelList.append(pascalList)
        return pascal(currLevel + INCREMENT, levelsToMake, levelList)

##################################################################
# inputValidator() evaluates the levelInput and see's if input is 
#                  greater than zero
# Input: levelInput; an int; represents height of triangle
# Output: result; a boolean; represents if input is valid

def inputValidator(levelInput):
    
    result = True

    # Only returns false if levelInputis less than or equal to LOWER_BOUND
    if levelInput <= LOWER_BOUND:
        print("Your number must be positive (greater than zero)")
        result = False

    return result

def main():

    print("Welcome to the Pascal's Triangle Generator")
    valid = False

    currLevel = LOWER_BOUND
    levelList = []

    while valid != True:
        
        levelInput = int(input("Please enter the number of levels to generate: "))
        validNum = inputValidator(levelInput)

        # Exits while loop if validNum returns true
        if validNum == True:
            valid = True
    
    # Calls recursive function
    pascal(currLevel, levelInput, levelList) 
    
main()
